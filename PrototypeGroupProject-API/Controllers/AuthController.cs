using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using MongoDB.Bson;
using PrototypeGroupProject_API.Data;
using PrototypeGroupProject_API.Models.DTO;
using PrototypeGroupProject_API.Models.Entities;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
//Note: could refactor this to use a service(IAuthService for instance)  https://www.youtube.com/watch?v=6EEltKS8AwA for ref but ill bring up with group next meeting
namespace PrototypeGroupProject_API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly IPasswordHasher<StaffEntity> _passwordHasher;
        private readonly AppDbContext _context;
        private readonly IConfiguration _configuration;
        //add db context here along with password hasher service
        public AuthController(IPasswordHasher<StaffEntity> passwordHasher, AppDbContext context, IConfiguration configuration)
        {
            _passwordHasher = passwordHasher;
            _context = context;
            _configuration = configuration;
        }
        //would probably need to have a register section on dashboard for admin only to hit this endpoint
        //should i do a register endpoint here also? coz how are we adding staff members otherwise, i think so but we create it via swagger for now
        [HttpPost("registerStaff")]      //could do registerStaff to be more specific
        public async Task<IActionResult> Register(StaffRegisterDto request)
        {
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }
            //check if username already exists
            var existingUser = await _context.Staff.AnyAsync(s => s.Username == request.Username);      //using linq to check if any user exists with the same username
            if (existingUser)   //if true
            {
                return Conflict(new { Message = "User already exists" });       //return basic conflict response
            }
            //create new staff entity
            var staff = new StaffEntity
            {
                //id could be autogenerated by mongodb
                Id = ObjectId.GenerateNewId(),      //for now hardcoding generation as we havnt integrated the db yet
                Username = request.Username
            }; 
            //hash password
            staff.PasswordHash = _passwordHasher.HashPassword(staff, request.Password);
            staff.Role = "Staff";       //temp again just hardcoding to prevent escalation not sure if this is best place
            //save to db here
            _context.Add(staff);
            await _context.SaveChangesAsync();
            return Ok(new { Message = $"Registration successful for id: {staff.Id.ToString()}, username: {staff.Username}" });
        }
        //https://www.youtube.com/watch?v=6EEltKS8AwA for ref
        //could do loginStaff to be more specific
        [HttpPost("loginStaff")]     //will specifiy endpopint more indetail when integrating with the mobile app, ie dashboardLogin or something along the lines
        public async Task<IActionResult> Login(StaffLoginDto request)
        {
            if (!ModelState.IsValid)
            {
                return ValidationProblem(ModelState);
            }
            //find user by username
            var staff = await _context.Staff.FirstOrDefaultAsync(s => s.Username == request.Username);      //if u dont know linq, it basically checks the staff collection for any record with the same username and returns the first one it finds
            if (staff == null)  //if no user found
            {
                return Unauthorized(new { Message = "Invalid credentials" });       //abstraction for failure to login for better security prac
            }
            //verify hashed password
            var result = _passwordHasher.VerifyHashedPassword(staff, staff.PasswordHash, request.Password);
            if (result == PasswordVerificationResult.Failed)
            {
                return Unauthorized(new { Message = "Invalid credentials" });       //abstraction for failure to login for better security prac
            }
            //replace with jwt generation later
            var token = CreateJwtToken(staff);
            return Ok(new StaffLoginResponseDto
            {
                Token = token,
                Username = staff.Username,
                Role = staff.Role,
                ExpiresUtc = DateTime.UtcNow.AddMinutes(30)      //can change

            });

        }

        //creating token
        private string CreateJwtToken(StaffEntity staff)
        {
            var claims = new List<Claim>
            {
                new Claim(ClaimTypes.NameIdentifier, staff.Id.ToString()),
                new Claim(ClaimTypes.Name, staff.Username),
                new Claim(ClaimTypes.Role, staff.Role)
            };
            //now we need a signing key
            var key = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(_configuration.GetValue<string>("JwtSettings:Token")!));

            //now we create creds
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha512);        //can change algorithm if needed, need a length of 64 characters --changed from SecurityAlgorithms.HmacSha512Signature to enable more crossplatform support for decoding
            //now we need descriptor
            var tokenDescriptor = new JwtSecurityToken(
                issuer: _configuration.GetValue<string>("JwtSettings:Issuer"),
                audience: _configuration.GetValue<string>("JwtSettings:Audience"),
                claims: claims,
                expires: DateTime.UtcNow.AddMinutes(30),   //token valid for 1 day, can change later?
                signingCredentials: creds
            );
            return new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);  //return the token as a string
        }

        //making sure endpoints are authenticated, using test endpoints
        [Authorize(Roles = "Staff")]        //only staff
        [HttpGet("staff")]  //route
        public IActionResult StaffOnlyEndpoint()
        {
            return Ok("You are authenticated, Staff");
        }

        [Authorize(Roles = "Admin")]        //only admin
        [HttpGet("admin")]      //route
        public IActionResult AdminOnlyEndpoint()
        {
            return Ok("You are authenticated, Admin");
        }
    }
}
